<!doctype html>
<html lang="en" data-lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>I Ching Fortune Guide</title>
  <link href='/style.css' rel='stylesheet'>
</head>
<body>
  <main class="saju">
    <header>
      <div>
        <a class="nav-link" id="home-link" href="/index.html">Back to Lotto</a>
        <h1 id="title">I Ching Fortune Guide</h1>
        <p id="subtitle">Enter your birth date and time to see a detailed I Ching reading.</p>
      </div>
      <div class="lang-switch">
        <label for="language">Language</label>
        <select id="language" name="language" aria-label="Language">
          <option value="en">English</option>
          <option value="ko">한국어</option>
          <option value="ja">日本語</option>
          <option value="zh">中文</option>
        </select>
      </div>
    </header>

    <form id="fortune-form">
      <div class="grid">
        <div>
          <label id="calendar-type-label" for="calendar-type">Calendar</label>
          <select id="calendar-type" name="calendar-type">
            <option value="solar">Solar</option>
            <option value="lunar">Lunar</option>
          </select>
        </div>
        <div>
          <label id="timezone-label" for="timezone">Time zone</label>
          <select id="timezone" name="timezone"></select>
        </div>
      </div>
      <div class="grid">
        <div id="solar-fields">
          <label id="birth-date-label" for="birth-date">Birth date</label>
          <input id="birth-date" name="birth-date" type="date" required />
        </div>
        <div id="lunar-fields" class="lunar-fields" hidden>
          <div class="grid">
            <div>
              <label id="lunar-year-label" for="lunar-year">Lunar year</label>
              <input id="lunar-year" name="lunar-year" type="number" min="1900" max="2100" />
            </div>
            <div>
              <label id="lunar-month-label" for="lunar-month">Lunar month</label>
              <input id="lunar-month" name="lunar-month" type="number" min="1" max="12" />
            </div>
            <div>
              <label id="lunar-day-label" for="lunar-day">Lunar day</label>
              <input id="lunar-day" name="lunar-day" type="number" min="1" max="30" />
            </div>
          </div>
          <label class="inline" id="leap-month-label">
            <input id="leap-month" type="checkbox" />
            <span id="leap-month-text">Leap month</span>
          </label>
        </div>
        <div>
          <label id="birth-time-label" for="birth-time">Birth time</label>
          <input id="birth-time" name="birth-time" type="time" required />
        </div>
      </div>
      <div class="actions">
        <button id="generate" type="submit">Get Fortune</button>
        <span id="helper">Your input is only used on this device.</span>
      </div>
      <div id="status" class="status" role="status"></div>
    </form>

    <section id="result" class="result" hidden>
      <div id="meta"></div>
      <h2 id="result-title">Your Hexagram</h2>
      <p id="result-summary"></p>
      <div class="details-grid">
        <div class="detail-card">
          <h3 id="calendar-title">Calendar conversion</h3>
          <div id="calendar-info" class="detail-list"></div>
        </div>
        <div class="detail-card">
          <h3 id="bazi-title">Four Pillars</h3>
          <div id="bazi-info" class="detail-list"></div>
          <div id="bazi-table" class="bazi-table"></div>
        </div>
      </div>
      <div class="hexagrams">
        <div class="hexagram-card">
          <h3 id="base-title">Primary Hexagram</h3>
          <div class="hexagram-lines" id="base-lines" aria-hidden="true"></div>
          <p id="base-desc"></p>
        </div>
        <div class="hexagram-card">
          <h3 id="changed-title">Changed Hexagram</h3>
          <div class="hexagram-lines" id="changed-lines" aria-hidden="true"></div>
          <p id="changed-desc"></p>
        </div>
      </div>
      <div class="sections" id="sections"></div>
      <div class="method" id="method"></div>
    </section>
  </main>

  <script src="/lib/lunar.js"></script>
  <script>
    const translations = {
      en: {
        title: "I Ching Fortune Guide",
        subtitle: "Enter your birth date and time to see a detailed I Ching reading.",
        label: "Language",
        home: "Back to Lotto",
        calendarTypeLabel: "Calendar",
        solarOption: "Solar (Gregorian)",
        lunarOption: "Lunar (Korean)",
        timezoneLabel: "Time zone",
        autoTimezone: "Auto (browser)",
        kstTimezone: "Korea Standard Time",
        date: "Birth date",
        lunarYear: "Lunar year",
        lunarMonth: "Lunar month",
        lunarDay: "Lunar day",
        leapMonth: "Leap month",
        time: "Birth time",
        button: "Get Fortune",
        helper: "Your input is only used on this device.",
        error: "Something went wrong. Please check your inputs and try again.",
        errorDetail: "Details",
        missing: "Please fill out the required date and time fields.",
        resultTitle: "Your Hexagram",
        summaryPrefix: "Core theme:",
        calendarTitle: "Calendar conversion",
        baziTitle: "Four Pillars (BaZi)",
        localTimeLabel: "Input time",
        kstTimeLabel: "Converted KST",
        solarLabel: "Solar date",
        lunarLabel: "Lunar date",
        lunarInputLabel: "Lunar input",
        jieqiLabel: "Jieqi",
        baziLabel: "BaZi",
        wuXingLabel: "Five elements",
        naYinLabel: "Na Yin",
        pillarYear: "Year",
        pillarMonth: "Month",
        pillarDay: "Day",
        pillarTime: "Hour",
        baseTitle: "Primary Hexagram",
        changedTitle: "Changed Hexagram",
        upperLabel: "Upper trigram",
        lowerLabel: "Lower trigram",
        movingLabel: "Changing line",
        hourLabel: "Double-hour",
        methodTitle: "Calculation method",
        methodIntro:
          "Uses Jieqi-based BaZi. Converts Heavenly Stems and Earthly Branches to numbers, then uses the total for upper trigram (mod 8), lower trigram (mod 8), and moving line (mod 6).",
        methodPeriodNote: "Period forecasts blend the current KST date into the base BaZi totals.",
        sections: {
          overall: "Overall",
          career: "Career",
          love: "Love",
          money: "Money",
          health: "Health",
          advice: "Guidance",
          daily: "Today",
          monthly: "This Month",
          yearly: "This Year",
          lifetime: "Overall Path",
        },
      },
      ko: {
        title: "주역 운세 안내",
        subtitle: "생년월일과 시간을 입력하면 상세한 주역 운세를 확인할 수 있어요.",
        label: "언어",
        home: "로또로 돌아가기",
        calendarTypeLabel: "달력",
        solarOption: "양력",
        lunarOption: "음력",
        timezoneLabel: "시간대",
        autoTimezone: "자동 (브라우저)",
        kstTimezone: "한국 표준시",
        date: "생년월일",
        lunarYear: "음력 연도",
        lunarMonth: "음력 월",
        lunarDay: "음력 일",
        leapMonth: "윤달",
        time: "태어난 시간",
        button: "운세 보기",
        helper: "입력값은 이 기기에서만 사용됩니다.",
        error: "입력값을 확인한 뒤 다시 시도해주세요.",
        errorDetail: "오류 상세",
        missing: "생년월일과 시간을 모두 입력해주세요.",
        resultTitle: "나의 괘",
        summaryPrefix: "핵심 주제:",
        calendarTitle: "달력 변환",
        baziTitle: "사주팔자",
        localTimeLabel: "입력 시간",
        kstTimeLabel: "한국 시간",
        solarLabel: "양력",
        lunarLabel: "음력",
        lunarInputLabel: "입력 음력",
        jieqiLabel: "절기",
        baziLabel: "팔자",
        wuXingLabel: "오행",
        naYinLabel: "납음",
        pillarYear: "년주",
        pillarMonth: "월주",
        pillarDay: "일주",
        pillarTime: "시주",
        baseTitle: "정괘",
        changedTitle: "변괘",
        upperLabel: "상괘",
        lowerLabel: "하괘",
        movingLabel: "변효",
        hourLabel: "시각(시주)",
        methodTitle: "계산 방식",
        methodIntro:
          "절기 기준 사주팔자를 사용합니다. 천간·지지를 수치로 변환해 상괘(mod 8), 하괘(mod 8), 변효(mod 6)를 계산합니다.",
        methodPeriodNote: "기간별 운세는 한국 시간 기준 현재 날짜 값을 사주 합계에 반영합니다.",
        sections: {
          overall: "전체운",
          career: "일·학업",
          love: "연애",
          money: "재물운",
          health: "건강",
          advice: "조언",
          daily: "오늘 운세",
          monthly: "이달 운세",
          yearly: "올해 운세",
          lifetime: "전체 운세",
        },
      },
      ja: {
        title: "易占いガイド",
        subtitle: "生年月日と時間を入力すると詳しい易の占いが表示されます。",
        label: "言語",
        home: "ロトへ戻る",
        calendarTypeLabel: "暦",
        solarOption: "太陽暦",
        lunarOption: "旧暦",
        timezoneLabel: "タイムゾーン",
        autoTimezone: "自動 (ブラウザ)",
        kstTimezone: "韓国標準時",
        date: "生年月日",
        lunarYear: "旧暦の年",
        lunarMonth: "旧暦の月",
        lunarDay: "旧暦の日",
        leapMonth: "閏月",
        time: "出生時間",
        button: "占いを見る",
        helper: "入力はこの端末内のみで使用されます。",
        error: "入力内容を確認してもう一度お試しください。",
        errorDetail: "詳細",
        missing: "生年月日と時間を入力してください。",
        resultTitle: "あなたの卦",
        summaryPrefix: "中心テーマ:",
        calendarTitle: "暦の変換",
        baziTitle: "四柱推命",
        localTimeLabel: "入力時刻",
        kstTimeLabel: "韓国時刻",
        solarLabel: "太陽暦",
        lunarLabel: "旧暦",
        lunarInputLabel: "入力旧暦",
        jieqiLabel: "節気",
        baziLabel: "四柱",
        wuXingLabel: "五行",
        naYinLabel: "納音",
        pillarYear: "年柱",
        pillarMonth: "月柱",
        pillarDay: "日柱",
        pillarTime: "時柱",
        baseTitle: "本卦",
        changedTitle: "之卦",
        upperLabel: "上卦",
        lowerLabel: "下卦",
        movingLabel: "変爻",
        hourLabel: "時刻",
        methodTitle: "算出方法",
        methodIntro:
          "節気基準の四柱を使用します。干支を数値化し、上卦(mod 8)、下卦(mod 8)、変爻(mod 6)を算出します。",
        methodPeriodNote: "期間別の運勢は韓国時間の現在日付を四柱の合計に反映します。",
        sections: {
          overall: "総合運",
          career: "仕事・学業",
          love: "恋愛",
          money: "金運",
          health: "健康",
          advice: "助言",
          daily: "今日の運勢",
          monthly: "今月の運勢",
          yearly: "今年の運勢",
          lifetime: "総合運",
        },
      },
      zh: {
        title: "周易运势指南",
        subtitle: "输入出生日期和时间即可查看详细周易运势。",
        label: "语言",
        home: "返回大乐透",
        calendarTypeLabel: "历法",
        solarOption: "公历",
        lunarOption: "农历",
        timezoneLabel: "时区",
        autoTimezone: "自动 (浏览器)",
        kstTimezone: "韩国标准时间",
        date: "出生日期",
        lunarYear: "农历年",
        lunarMonth: "农历月",
        lunarDay: "农历日",
        leapMonth: "闰月",
        time: "出生时间",
        button: "查看运势",
        helper: "输入仅在本设备使用。",
        error: "请检查输入后重试。",
        errorDetail: "错误详情",
        missing: "请填写出生日期与时间。",
        resultTitle: "你的卦象",
        summaryPrefix: "核心主题:",
        calendarTitle: "历法转换",
        baziTitle: "四柱八字",
        localTimeLabel: "输入时间",
        kstTimeLabel: "韩国时间",
        solarLabel: "公历",
        lunarLabel: "农历",
        lunarInputLabel: "输入农历",
        jieqiLabel: "节气",
        baziLabel: "八字",
        wuXingLabel: "五行",
        naYinLabel: "纳音",
        pillarYear: "年柱",
        pillarMonth: "月柱",
        pillarDay: "日柱",
        pillarTime: "时柱",
        baseTitle: "本卦",
        changedTitle: "之卦",
        upperLabel: "上卦",
        lowerLabel: "下卦",
        movingLabel: "变爻",
        hourLabel: "时辰",
        methodTitle: "计算方式",
        methodIntro:
          "采用节气定八字，将天干地支数值化后计算上卦(mod 8)、下卦(mod 8)与变爻(mod 6)。",
        methodPeriodNote: "分段运势会将韩国时间的当前日期加入八字合计。",
        sections: {
          overall: "整体运势",
          career: "事业学业",
          love: "感情",
          money: "财运",
          health: "健康",
          advice: "建议",
          daily: "今日运势",
          monthly: "本月运势",
          yearly: "今年运势",
          lifetime: "整体运势",
        },
      },
    };

    const trigrams = [
      {
        key: "qian",
        en: { name: "Heaven", trait: "clarity and leadership" },
        ko: { name: "건(乾)", trait: "맑은 기운과 리더십" },
        ja: { name: "乾", trait: "澄んだ気とリーダーシップ" },
        zh: { name: "乾", trait: "清晰与领导力" },
      },
      {
        key: "dui",
        en: { name: "Lake", trait: "joyful openness" },
        ko: { name: "태(兌)", trait: "밝은 소통과 즐거움" },
        ja: { name: "兌", trait: "開放的な喜び" },
        zh: { name: "兑", trait: "开放与喜悦" },
      },
      {
        key: "li",
        en: { name: "Fire", trait: "passion and insight" },
        ko: { name: "리(離)", trait: "열정과 통찰" },
        ja: { name: "離", trait: "情熱と洞察" },
        zh: { name: "离", trait: "热情与洞察" },
      },
      {
        key: "zhen",
        en: { name: "Thunder", trait: "bold momentum" },
        ko: { name: "진(震)", trait: "도전과 추진력" },
        ja: { name: "震", trait: "大胆な推進力" },
        zh: { name: "震", trait: "果断与推进力" },
      },
      {
        key: "xun",
        en: { name: "Wind", trait: "steady growth" },
        ko: { name: "손(巽)", trait: "꾸준한 성장" },
        ja: { name: "巽", trait: "着実な成長" },
        zh: { name: "巽", trait: "稳健与成长" },
      },
      {
        key: "kan",
        en: { name: "Water", trait: "deep intuition" },
        ko: { name: "감(坎)", trait: "깊은 직관" },
        ja: { name: "坎", trait: "深い直感" },
        zh: { name: "坎", trait: "深度直觉" },
      },
      {
        key: "gen",
        en: { name: "Mountain", trait: "stillness and focus" },
        ko: { name: "간(艮)", trait: "멈춤과 집중" },
        ja: { name: "艮", trait: "静けさと集中" },
        zh: { name: "艮", trait: "沉静与专注" },
      },
      {
        key: "kun",
        en: { name: "Earth", trait: "supportive harmony" },
        ko: { name: "곤(坤)", trait: "포용과 조화" },
        ja: { name: "坤", trait: "支える調和" },
        zh: { name: "坤", trait: "包容与协调" },
      },
    ];

    const trigramLines = [
      [1, 1, 1],
      [1, 1, 0],
      [1, 0, 1],
      [1, 0, 0],
      [0, 1, 1],
      [0, 1, 0],
      [0, 0, 1],
      [0, 0, 0],
    ];

    const trigramIndexByBits = new Map(
      trigramLines.map((lines, index) => [lines.join(""), index])
    );

    const lineAdvice = {
      en: [
        "The first line favors preparation before action.",
        "The second line asks for patience and steady effort.",
        "The third line signals tension; keep your balance.",
        "The fourth line rewards flexible thinking.",
        "The fifth line highlights a peak moment; lead with integrity.",
        "The sixth line suggests completion and graceful release.",
      ],
      ko: [
        "초효는 행동 전 준비가 필요함을 말합니다.",
        "이효는 인내와 꾸준함을 요구합니다.",
        "삼효는 긴장이 생기니 균형을 지키세요.",
        "사효는 유연한 사고가 성과를 부릅니다.",
        "오효는 정점의 순간이니 바른 리더십이 필요합니다.",
        "상효는 마무리와 내려놓음을 권합니다.",
      ],
      ja: [
        "初爻は準備を整えることが大切だと示します。",
        "二爻は忍耐と地道な努力を求めます。",
        "三爻は緊張が生まれるのでバランスを守りましょう。",
        "四爻は柔軟な発想が成果を呼びます。",
        "五爻は頂点の時期、誠実なリーダーシップが鍵です。",
        "上爻は締めくくりと手放しを示します。",
      ],
      zh: [
        "初爻提示先准备再行动。",
        "二爻强调耐心与稳定推进。",
        "三爻提醒张力上升，需保持平衡。",
        "四爻鼓励灵活思考以促成结果。",
        "五爻处在高点，务必以诚信引领。",
        "上爻意味着完成与适时放下。",
      ],
    };

    const sectionTemplates = {
      en: {
        overall: (upper, lower) =>
          `The interaction of ${upper.name} over ${lower.name} sets a tone of ${upper.trait} grounded by ${lower.trait}.`,
        career: (upper, lower) =>
          `In work and study, lead with ${upper.trait} while applying ${lower.trait} to daily tasks.`,
        love: (upper, lower) =>
          `Relationships deepen when ${upper.trait} meets the warmth of ${lower.trait}.`,
        money: (upper, lower) =>
          `Financial flow improves through ${lower.trait}, then expands with ${upper.trait}.`,
        health: (upper, lower) =>
          `Balance your energy: channel ${upper.trait} and rest with ${lower.trait}.`,
        advice: (upper, lower, line) =>
          `Focus on the changing line: ${line} Let ${upper.trait} guide the direction and ${lower.trait} steady the pace.`,
        daily: (upper, lower, line) =>
          `Today favors quick adjustments. ${line} Keep ${upper.trait} upfront while grounding decisions in ${lower.trait}.`,
        monthly: (upper, lower) =>
          `This month rewards steady progress. ${upper.trait} sets the goal, ${lower.trait} maintains momentum.`,
        yearly: (upper, lower) =>
          `This year expands through ${upper.trait} and matures with ${lower.trait}. Build long-term foundations.`,
        lifetime: (upper, lower) =>
          `Your overall path blends ${upper.trait} with ${lower.trait}, forming a resilient pattern over time.`,
      },
      ko: {
        overall: (upper, lower) =>
          `${upper.name}의 기운이 ${lower.name} 위에 놓이며 ${upper.trait}이(가) ${lower.trait}와 조화를 이룹니다.`,
        career: (upper, lower) =>
          `일과 학업에서는 ${upper.trait}을(를) 앞세우고, ${lower.trait}로 실행력을 다지세요.`,
        love: (upper, lower) =>
          `연애운은 ${upper.trait}이(가) ${lower.trait}와 만나면 안정됩니다.`,
        money: (upper, lower) =>
          `재물운은 ${lower.trait}로 기반을 쌓고 ${upper.trait}로 확장됩니다.`,
        health: (upper, lower) =>
          `${upper.trait}을(를) 펼치되 ${lower.trait}로 컨디션을 회복하세요.`,
        advice: (upper, lower, line) =>
          `변효 조언: ${line} ${upper.trait}이(가) 방향을 잡고 ${lower.trait}이(가) 속도를 조절합니다.`,
        daily: (upper, lower, line) =>
          `오늘은 빠른 조정이 필요합니다. ${line} ${upper.trait}을(를) 앞세우고 ${lower.trait}로 균형을 지키세요.`,
        monthly: (upper, lower) =>
          `이달은 꾸준함이 관건입니다. ${upper.trait}으로 목표를 세우고 ${lower.trait}로 진행력을 유지하세요.`,
        yearly: (upper, lower) =>
          `올해는 ${upper.trait}의 확장과 ${lower.trait}의 안정이 함께합니다. 장기 기반을 다지세요.`,
        lifetime: (upper, lower) =>
          `전체 운세는 ${upper.trait}과 ${lower.trait}의 흐름이 반복되며 큰 구조를 만듭니다.`,
      },
      ja: {
        overall: (upper, lower) =>
          `${upper.name}が${lower.name}の上にあり、${upper.trait}が${lower.trait}と調和します。`,
        career: (upper, lower) =>
          `仕事や学業では${upper.trait}を前面にし、${lower.trait}で実行力を整えましょう。`,
        love: (upper, lower) =>
          `恋愛は${upper.trait}が${lower.trait}と結びつくと安定します。`,
        money: (upper, lower) =>
          `金運は${lower.trait}で基盤を作り、${upper.trait}で広がります。`,
        health: (upper, lower) =>
          `${upper.trait}を発揮しつつ、${lower.trait}で体調を整えてください。`,
        advice: (upper, lower, line) =>
          `変爻の助言: ${line} ${upper.trait}で方向性を示し、${lower.trait}で歩みを整えましょう。`,
        daily: (upper, lower, line) =>
          `今日は微調整が鍵です。${line} ${upper.trait}を前に出しつつ、${lower.trait}で土台を整えましょう。`,
        monthly: (upper, lower) =>
          `今月は継続力が問われます。${upper.trait}で目標を定め、${lower.trait}で前進を保ちます。`,
        yearly: (upper, lower) =>
          `今年は${upper.trait}の拡大と${lower.trait}の安定が並走します。長期の基盤作りを。`,
        lifetime: (upper, lower) =>
          `総合的な流れは${upper.trait}と${lower.trait}が重なり合い、持続的な形をつくります。`,
      },
      zh: {
        overall: (upper, lower) =>
          `${upper.name}在上、${lower.name}在下，${upper.trait}与${lower.trait}相互呼应。`,
        career: (upper, lower) =>
          `事业与学业上，以${upper.trait}开局，并用${lower.trait}稳固执行。`,
        love: (upper, lower) =>
          `感情中，${upper.trait}与${lower.trait}相遇更易稳定。`,
        money: (upper, lower) =>
          `财运先由${lower.trait}打底，再以${upper.trait}扩展。`,
        health: (upper, lower) =>
          `保持能量平衡：发挥${upper.trait}，以${lower.trait}修复与恢复。`,
        advice: (upper, lower, line) =>
          `变爻提示：${line} 让${upper.trait}指引方向，${lower.trait}稳住节奏。`,
        daily: (upper, lower, line) =>
          `今日宜快速调整。${line} 用${upper.trait}定调，以${lower.trait}稳住选择。`,
        monthly: (upper, lower) =>
          `本月重在稳步推进。${upper.trait}设定目标，${lower.trait}保持节奏。`,
        yearly: (upper, lower) =>
          `今年是${upper.trait}扩展与${lower.trait}沉淀并行的一年，适合打长期基础。`,
        lifetime: (upper, lower) =>
          `整体运势呈现${upper.trait}与${lower.trait}交织的长期轨迹。`,
      },
    };

    const languageSelect = document.getElementById("language");
    const title = document.getElementById("title");
    const subtitle = document.getElementById("subtitle");
    const homeLink = document.getElementById("home-link");
    const calendarType = document.getElementById("calendar-type");
    const timezoneSelect = document.getElementById("timezone");
    const birthDateLabel = document.getElementById("birth-date-label");
    const birthTimeLabel = document.getElementById("birth-time-label");
    const calendarTypeLabel = document.getElementById("calendar-type-label");
    const timezoneLabel = document.getElementById("timezone-label");
    const lunarYearLabel = document.getElementById("lunar-year-label");
    const lunarMonthLabel = document.getElementById("lunar-month-label");
    const lunarDayLabel = document.getElementById("lunar-day-label");
    const leapMonthLabel = document.getElementById("leap-month-label");
    const solarFields = document.getElementById("solar-fields");
    const lunarFields = document.getElementById("lunar-fields");
    const lunarYearInput = document.getElementById("lunar-year");
    const lunarMonthInput = document.getElementById("lunar-month");
    const lunarDayInput = document.getElementById("lunar-day");
    const leapMonthInput = document.getElementById("leap-month");
    const leapMonthText = document.getElementById("leap-month-text");
    const button = document.getElementById("generate");
    const helper = document.getElementById("helper");
    const result = document.getElementById("result");
    const resultTitle = document.getElementById("result-title");
    const resultSummary = document.getElementById("result-summary");
    const calendarTitle = document.getElementById("calendar-title");
    const baziTitle = document.getElementById("bazi-title");
    const calendarInfo = document.getElementById("calendar-info");
    const baziInfo = document.getElementById("bazi-info");
    const baziTable = document.getElementById("bazi-table");
    const baseTitle = document.getElementById("base-title");
    const changedTitle = document.getElementById("changed-title");
    const baseLines = document.getElementById("base-lines");
    const changedLines = document.getElementById("changed-lines");
    const baseDesc = document.getElementById("base-desc");
    const changedDesc = document.getElementById("changed-desc");
    const meta = document.getElementById("meta");
    const sections = document.getElementById("sections");
    const method = document.getElementById("method");
    const status = document.getElementById("status");
    let lastReadingPayload = null;

    function normalizeLanguage(value) {
      if (!value) return "en";
      if (value.startsWith("ko")) return "ko";
      if (value.startsWith("ja")) return "ja";
      if (value.startsWith("zh")) return "zh";
      return "en";
    }

    function applyLanguage(lang) {
      const t = translations[lang] ?? translations.en;
      title.textContent = t.title;
      subtitle.textContent = t.subtitle;
      homeLink.textContent = t.home;
      calendarTypeLabel.textContent = t.calendarTypeLabel;
      timezoneLabel.textContent = t.timezoneLabel;
      birthDateLabel.textContent = t.date;
      birthTimeLabel.textContent = t.time;
      lunarYearLabel.textContent = t.lunarYear;
      lunarMonthLabel.textContent = t.lunarMonth;
      lunarDayLabel.textContent = t.lunarDay;
      leapMonthText.textContent = t.leapMonth;
      button.textContent = t.button;
      helper.textContent = t.helper;
      document.querySelector(".lang-switch label").textContent = t.label;
      resultTitle.textContent = t.resultTitle;
      calendarTitle.textContent = t.calendarTitle;
      baziTitle.textContent = t.baziTitle;
      baseTitle.textContent = t.baseTitle;
      changedTitle.textContent = t.changedTitle;
      document.documentElement.lang = lang;
      document.documentElement.dataset.lang = lang;
      document.title = t.title;
      calendarType.options[0].textContent = t.solarOption;
      calendarType.options[1].textContent = t.lunarOption;
    }

    function setStatus(message, isError = false) {
      status.textContent = message || "";
      status.classList.toggle("error", isError);
    }

    function getTimeZones() {
      if (typeof Intl.supportedValuesOf === "function") {
        return Intl.supportedValuesOf("timeZone");
      }
      return [
        "Asia/Seoul",
        "Asia/Tokyo",
        "Asia/Shanghai",
        "Asia/Hong_Kong",
        "America/New_York",
        "America/Los_Angeles",
        "Europe/London",
        "Europe/Paris",
        "Australia/Sydney",
      ];
    }

    function buildTimeZoneOptions(lang) {
      const t = translations[lang] ?? translations.en;
      timezoneSelect.innerHTML = "";
      const autoOption = document.createElement("option");
      autoOption.value = "auto";
      autoOption.textContent = t.autoTimezone;
      timezoneSelect.appendChild(autoOption);

      const kstOption = document.createElement("option");
      kstOption.value = "Asia/Seoul";
      kstOption.textContent = t.kstTimezone;
      timezoneSelect.appendChild(kstOption);

      getTimeZones().forEach((zone) => {
        if (zone === "Asia/Seoul") return;
        const option = document.createElement("option");
        option.value = zone;
        option.textContent = zone;
        timezoneSelect.appendChild(option);
      });
    }

    function resolveTimeZone() {
      if (timezoneSelect.value === "auto") {
        return Intl.DateTimeFormat().resolvedOptions().timeZone || "Asia/Seoul";
      }
      return timezoneSelect.value;
    }

    function formatParts(date, timeZone) {
      const formatter = new Intl.DateTimeFormat("en-US", {
        timeZone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        hourCycle: "h23",
      });
      const parts = Object.fromEntries(
        formatter.formatToParts(date).map((part) => [part.type, part.value])
      );
      return {
        year: Number(parts.year),
        month: Number(parts.month),
        day: Number(parts.day),
        hour: Number(parts.hour),
        minute: Number(parts.minute),
        second: Number(parts.second),
      };
    }

    function zonedTimeToUtc(parts, timeZone) {
      const utcDate = new Date(
        Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, parts.second)
      );
      const tzParts = formatParts(utcDate, timeZone);
      const asTimeZone = Date.UTC(
        tzParts.year,
        tzParts.month - 1,
        tzParts.day,
        tzParts.hour,
        tzParts.minute,
        tzParts.second
      );
      const offset = asTimeZone - utcDate.getTime();
      return new Date(utcDate.getTime() - offset);
    }

    function formatDateTime(parts) {
      const pad = (value) => String(value).padStart(2, "0");
      return `${parts.year}-${pad(parts.month)}-${pad(parts.day)} ${pad(parts.hour)}:${pad(parts.minute)}`;
    }

    function toggleCalendarFields(type) {
      const isLunar = type === "lunar";
      solarFields.hidden = isLunar;
      lunarFields.hidden = !isLunar;
      document.getElementById("birth-date").required = !isLunar;
      document.getElementById("birth-date").disabled = isLunar;
      lunarYearInput.required = isLunar;
      lunarMonthInput.required = isLunar;
      lunarDayInput.required = isLunar;
      lunarYearInput.disabled = !isLunar;
      lunarMonthInput.disabled = !isLunar;
      lunarDayInput.disabled = !isLunar;
      leapMonthInput.disabled = !isLunar;
    }

    function getGanIndex(gan) {
      return LunarUtil.GAN.indexOf(gan) + 1;
    }

    function getZhiIndex(zhi) {
      return LunarUtil.ZHI.indexOf(zhi) + 1;
    }

    function buildHexagramLines(upperIndex, lowerIndex) {
      return [...trigramLines[lowerIndex], ...trigramLines[upperIndex]];
    }

    function linesToNumber(lines) {
      return lines.reduce((acc, bit, index) => acc + (bit << index), 0) + 1;
    }

    function flipLine(lines, index) {
      const next = [...lines];
      next[index] = next[index] === 1 ? 0 : 1;
      return next;
    }

    function linesToTrigrams(lines) {
      const lowerBits = lines.slice(0, 3).join("");
      const upperBits = lines.slice(3, 6).join("");
      return {
        lowerIndex: trigramIndexByBits.get(lowerBits),
        upperIndex: trigramIndexByBits.get(upperBits),
      };
    }

    function renderLines(container, lines, movingIndex) {
      const reversed = [...lines].reverse();
      const movingPosition =
        typeof movingIndex === "number" ? reversed.length - 1 - movingIndex : -1;
      container.innerHTML = reversed
        .map((bit, idx) => {
          const classes = ["hex-line", bit === 1 ? "yang" : "yin"];
          if (idx === movingPosition) classes.push("moving");
          return `<div class=\"${classes.join(" ")}\"></div>`;
        })
        .join("");
    }

    function computePayload() {
      if (!window.Lunar || !window.Solar || !window.LunarUtil) {
        throw new Error("Lunar library not available");
      }
      const dateValue = document.getElementById("birth-date").value;
      const timeValue = document.getElementById("birth-time").value;
      if (!timeValue) return null;

      const [hour, minute] = timeValue.split(":").map(Number);
      const inputTimeZone = resolveTimeZone();

      let localSolarParts = null;
      let inputCalendar = calendarType.value;
      let inputLunarLabel = "";

      if (inputCalendar === "solar") {
        if (!dateValue) return null;
        const [year, month, day] = dateValue.split("-").map(Number);
        localSolarParts = { year, month, day, hour, minute, second: 0 };
      } else {
        const lunarYear = Number(lunarYearInput.value);
        const lunarMonth = Number(lunarMonthInput.value);
        const lunarDay = Number(lunarDayInput.value);
        if (!lunarYear || !lunarMonth || !lunarDay) return null;
        const monthValue = leapMonthInput.checked ? -lunarMonth : lunarMonth;
        let lunar = null;
        try {
          lunar = Lunar.fromYmdHms(lunarYear, monthValue, lunarDay, hour, minute, 0);
        } catch (error) {
          throw new Error(`Invalid lunar date: ${error.message}`);
        }
        const solar = lunar.getSolar();
        localSolarParts = {
          year: solar.getYear(),
          month: solar.getMonth(),
          day: solar.getDay(),
          hour: solar.getHour(),
          minute: solar.getMinute(),
          second: solar.getSecond(),
        };
        inputLunarLabel = `${lunarYear}-${String(lunarMonth).padStart(2, "0")}-${String(
          lunarDay
        ).padStart(2, "0")}${leapMonthInput.checked ? " (leap)" : ""}`;
      }

      const utcDate = zonedTimeToUtc(localSolarParts, inputTimeZone);
      const kstParts = formatParts(utcDate, "Asia/Seoul");
      let kstSolar = null;
      try {
        kstSolar = Solar.fromYmdHms(
          kstParts.year,
          kstParts.month,
          kstParts.day,
          kstParts.hour,
          kstParts.minute,
          0
        );
      } catch (error) {
        throw new Error(`Invalid solar date: ${error.message}`);
      }
      const lunar = kstSolar.getLunar();
      const eightChar = lunar.getEightChar();

      const ganIndices = {
        year: getGanIndex(eightChar.getYearGan()),
        month: getGanIndex(eightChar.getMonthGan()),
        day: getGanIndex(eightChar.getDayGan()),
        time: getGanIndex(eightChar.getTimeGan()),
      };
      const zhiIndices = {
        year: getZhiIndex(eightChar.getYearZhi()),
        month: getZhiIndex(eightChar.getMonthZhi()),
        day: getZhiIndex(eightChar.getDayZhi()),
        time: getZhiIndex(eightChar.getTimeZhi()),
      };

      const upperSum =
        ganIndices.year +
        zhiIndices.year +
        ganIndices.month +
        zhiIndices.month +
        ganIndices.day +
        zhiIndices.day;
      const lowerSum = upperSum + ganIndices.time + zhiIndices.time;
      const upperIndex = (upperSum % 8 || 8) - 1;
      const lowerIndex = (lowerSum % 8 || 8) - 1;
      const movingLine = lowerSum % 6 === 0 ? 6 : lowerSum % 6;

      const baseLines = buildHexagramLines(upperIndex, lowerIndex);
      const baseNumber = linesToNumber(baseLines);
      const changedLines = flipLine(baseLines, movingLine - 1);
      const changedNumber = linesToNumber(changedLines);
      const changedTrigrams = linesToTrigrams(changedLines);

      const lunarMonthValue = lunar.getMonth();
      const isLeapMonth = lunarMonthValue < 0;
      const lunarText = `${lunar.getYear()}-${String(Math.abs(lunarMonthValue)).padStart(
        2,
        "0"
      )}-${String(lunar.getDay()).padStart(2, "0")}${isLeapMonth ? " (leap)" : ""}`;

      const currentJieQi = lunar.getCurrentJieQi();
      const jieqiName = currentJieQi ? currentJieQi.getName() : lunar.getJieQi() || "-";

      const currentKstParts = formatParts(new Date(), "Asia/Seoul");

      return {
        inputCalendar,
        inputTimeZone,
        inputLunarLabel,
        localSolarParts,
        kstParts,
        currentKstParts,
        lunarText,
        jieqi: jieqiName,
        eightChar,
        upperIndex,
        lowerIndex,
        upperSum,
        lowerSum,
        movingLine,
        baseLines,
        baseNumber,
        changedLines,
        changedNumber,
        changedTrigrams,
      };
    }

    function buildReading(lang, payload) {
      const t = translations[lang] ?? translations.en;
      const upper = trigrams[payload.upperIndex][lang];
      const lower = trigrams[payload.lowerIndex][lang];
      const template = sectionTemplates[lang] || sectionTemplates.en;
      const lineText = lineAdvice[lang]
        ? lineAdvice[lang][payload.movingLine - 1]
        : lineAdvice.en[payload.movingLine - 1];

      const changedUpper = trigrams[payload.changedTrigrams.upperIndex][lang];
      const changedLower = trigrams[payload.changedTrigrams.lowerIndex][lang];

      const resultMeta = [
        `<span class="pill">#${payload.baseNumber}</span>`,
        `<span class="pill">${upper.name}</span>`,
        `<span class="pill">${lower.name}</span>`,
      ].join(" ");

      const summary = `${t.summaryPrefix} ${upper.trait} + ${lower.trait}`;
      const baseDesc = `${t.upperLabel}: ${upper.name} · ${upper.trait} / ${t.lowerLabel}: ${lower.name} · ${lower.trait}`;
      const changedDesc = `${t.upperLabel}: ${changedUpper.name} · ${changedUpper.trait} / ${t.lowerLabel}: ${changedLower.name} · ${changedLower.trait}`;

      function buildPeriodSums(seed) {
        const upperSum = payload.upperSum + seed;
        const lowerSum = payload.lowerSum + seed;
        const upperIndex = (upperSum % 8 || 8) - 1;
        const lowerIndex = (lowerSum % 8 || 8) - 1;
        const movingLine = lowerSum % 6 === 0 ? 6 : lowerSum % 6;
        return { upperSum, lowerSum, upperIndex, lowerIndex, movingLine };
      }

      const now = payload.currentKstParts;
      const dailySeed = now.year + now.month + now.day;
      const monthlySeed = now.year + now.month;
      const yearlySeed = now.year;

      const dailyData = buildPeriodSums(dailySeed);
      const monthlyData = buildPeriodSums(monthlySeed);
      const yearlyData = buildPeriodSums(yearlySeed);

      const dailyUpper = trigrams[dailyData.upperIndex][lang];
      const dailyLower = trigrams[dailyData.lowerIndex][lang];
      const monthlyUpper = trigrams[monthlyData.upperIndex][lang];
      const monthlyLower = trigrams[monthlyData.lowerIndex][lang];
      const yearlyUpper = trigrams[yearlyData.upperIndex][lang];
      const yearlyLower = trigrams[yearlyData.lowerIndex][lang];

      const dailyLine = lineAdvice[lang]
        ? lineAdvice[lang][dailyData.movingLine - 1]
        : lineAdvice.en[dailyData.movingLine - 1];
      const monthlyLine = lineAdvice[lang]
        ? lineAdvice[lang][monthlyData.movingLine - 1]
        : lineAdvice.en[monthlyData.movingLine - 1];
      const yearlyLine = lineAdvice[lang]
        ? lineAdvice[lang][yearlyData.movingLine - 1]
        : lineAdvice.en[yearlyData.movingLine - 1];

      const items = [
        { key: "overall", text: template.overall(upper, lower) },
        { key: "career", text: template.career(upper, lower) },
        { key: "love", text: template.love(upper, lower) },
        { key: "money", text: template.money(upper, lower) },
        { key: "health", text: template.health(upper, lower) },
        { key: "advice", text: template.advice(upper, lower, lineText) },
        { key: "daily", text: template.daily(dailyUpper, dailyLower, dailyLine) },
        { key: "monthly", text: template.monthly(monthlyUpper, monthlyLower, monthlyLine) },
        { key: "yearly", text: template.yearly(yearlyUpper, yearlyLower, yearlyLine) },
        { key: "lifetime", text: template.lifetime(upper, lower) },
      ];

      const pillars = [
        {
          label: t.pillarYear,
          value: payload.eightChar.getYear(),
          wuxing: payload.eightChar.getYearWuXing(),
          nayin: payload.eightChar.getYearNaYin(),
        },
        {
          label: t.pillarMonth,
          value: payload.eightChar.getMonth(),
          wuxing: payload.eightChar.getMonthWuXing(),
          nayin: payload.eightChar.getMonthNaYin(),
        },
        {
          label: t.pillarDay,
          value: payload.eightChar.getDay(),
          wuxing: payload.eightChar.getDayWuXing(),
          nayin: payload.eightChar.getDayNaYin(),
        },
        {
          label: t.pillarTime,
          value: payload.eightChar.getTime(),
          wuxing: payload.eightChar.getTimeWuXing(),
          nayin: payload.eightChar.getTimeNaYin(),
        },
      ];

      const methodDetail = `${t.methodTitle}: ${t.methodIntro} ${t.movingLabel}: ${payload.movingLine} · ${t.upperLabel}: (${payload.upperSum}) mod 8 → ${payload.upperIndex + 1}, ${t.lowerLabel}: (${payload.lowerSum}) mod 8 → ${payload.lowerIndex + 1}. ${t.methodPeriodNote}`;

      return {
        resultMeta,
        summary,
        items,
        baseDesc,
        changedDesc,
        pillars,
        methodDetail,
      };
    }

    function renderReading(lang, payload, reading) {
      meta.innerHTML = reading.resultMeta;
      resultSummary.textContent = reading.summary;
      baseDesc.textContent = reading.baseDesc;
      changedDesc.textContent = reading.changedDesc;
      renderLines(baseLines, payload.baseLines, payload.movingLine - 1);
      renderLines(changedLines, payload.changedLines);
      baseTitle.textContent = `${translations[lang].baseTitle} #${payload.baseNumber}`;
      changedTitle.textContent = `${translations[lang].changedTitle} #${payload.changedNumber}`;
      method.textContent = reading.methodDetail;

      const calendarRows = [
        `<div><strong>${translations[lang].calendarTypeLabel}:</strong> ${
          payload.inputCalendar === "solar"
            ? translations[lang].solarOption
            : translations[lang].lunarOption
        }</div>`,
        `<div><strong>${translations[lang].localTimeLabel}:</strong> ${formatDateTime(
          payload.localSolarParts
        )} (${payload.inputTimeZone})</div>`,
        `<div><strong>${translations[lang].kstTimeLabel}:</strong> ${formatDateTime(
          payload.kstParts
        )} (Asia/Seoul)</div>`,
      ];

      if (payload.inputCalendar === "lunar" && payload.inputLunarLabel) {
        calendarRows.push(
          `<div><strong>${translations[lang].lunarInputLabel}:</strong> ${payload.inputLunarLabel}</div>`
        );
      }

      calendarRows.push(
        `<div><strong>${translations[lang].solarLabel}:</strong> ${formatDateTime(
          payload.kstParts
        )}</div>`,
        `<div><strong>${translations[lang].lunarLabel}:</strong> ${payload.lunarText}</div>`,
        `<div><strong>${translations[lang].jieqiLabel}:</strong> ${payload.jieqi}</div>`
      );

      calendarInfo.innerHTML = calendarRows.join("");

      baziInfo.innerHTML = `<div><strong>${translations[lang].baziLabel}:</strong> ${
        payload.eightChar.getYear()
      } ${payload.eightChar.getMonth()} ${payload.eightChar.getDay()} ${payload.eightChar.getTime()}</div>`;

      baziTable.innerHTML = reading.pillars
        .map(
          (pillar) => `
          <div class="bazi-row">
            <div class="bazi-cell">${pillar.label}</div>
            <div class="bazi-cell">${pillar.value}</div>
            <div class="bazi-cell">${translations[lang].wuXingLabel}: ${pillar.wuxing}</div>
            <div class="bazi-cell">${translations[lang].naYinLabel}: ${pillar.nayin}</div>
          </div>
        `
        )
        .join("");

      sections.innerHTML = reading.items
        .map(
          (item) => `
            <div class="section">
              <h3>${translations[lang].sections[item.key]}</h3>
              <p>${item.text}</p>
            </div>
          `
        )
        .join("");
      result.hidden = false;
    }

    const savedLanguage = localStorage.getItem("lotto-language") || navigator.language;
    const normalizedLanguage = normalizeLanguage(savedLanguage);
    languageSelect.value = normalizedLanguage in translations ? normalizedLanguage : "en";
    applyLanguage(languageSelect.value);
    buildTimeZoneOptions(languageSelect.value);

    const savedTimezone = localStorage.getItem("lotto-timezone") || "auto";
    if ([...timezoneSelect.options].some((option) => option.value === savedTimezone)) {
      timezoneSelect.value = savedTimezone;
    }

    toggleCalendarFields(calendarType.value);

    languageSelect.addEventListener("change", (event) => {
      const nextLanguage = event.target.value;
      localStorage.setItem("lotto-language", nextLanguage);
      applyLanguage(nextLanguage);
      const currentTimezone = timezoneSelect.value;
      buildTimeZoneOptions(nextLanguage);
      if ([...timezoneSelect.options].some((option) => option.value === currentTimezone)) {
        timezoneSelect.value = currentTimezone;
      }
      if (lastReadingPayload) {
        const reading = buildReading(nextLanguage, lastReadingPayload);
        renderReading(nextLanguage, lastReadingPayload, reading);
      }
    });

    calendarType.addEventListener("change", (event) => {
      toggleCalendarFields(event.target.value);
    });

    timezoneSelect.addEventListener("change", (event) => {
      localStorage.setItem("lotto-timezone", event.target.value);
    });

    document.getElementById("fortune-form").addEventListener("submit", (event) => {
      event.preventDefault();
      const lang = languageSelect.value;
      setStatus("");
      try {
        const data = computePayload();
        if (!data) {
          setStatus(translations[lang].missing, true);
          return;
        }
        lastReadingPayload = data;
        const reading = buildReading(lang, data);
        renderReading(lang, data, reading);
      } catch (error) {
        const detail = error && error.message ? ` (${translations[lang].errorDetail}: ${error.message})` : "";
        setStatus(`${translations[lang].error}${detail}`, true);
        console.error(error);
      }
    });
  </script>
</body>
</html>
